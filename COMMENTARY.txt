during change 1 (when splitting into DOD and OOP):

notice how we had to move to pointers as constructors caused us to lose control
of when the dude and tiles were initialised, and if we let them own what they
need to render, then they are trying to grab assets before they are ready to be
grabbed.


during change 2 (adding growing to the owls):

the DOD approach is to have a list of owls that are growing, and only increment
the growing timer of owls that might be growing. This means that the
non-growing owls don't get an update tick, and also that the non-growing owls
don't have a growing time field. This saves both time and space.

during update 4 (owls harvested, chest of gold, bears, woods):

having the seed count in the dude didn't seem bad earlier, but now with the owl
count and the gold count too, it's startig to look innappropriate from a DOD
perspective. But this is how games traditionally handle per character
attributes, so the OOP version is starting to need more accessors.

In the object-oriented project, wer're going to be using a "world" object as
the tendency to name things often leads to early structuring in OO C++
development. The data-oriented approach is teetering on that decision because
of the rule of thumb that is personal to me, which is if you have two things,
don't genericise, but if you have three, then you probably should. Until there
is a third destination, the data-oriented approach will stick with a "are you
in the woods" check, as at this stage it's the simplest thing to do.

I notice during this change, the encapsulation of state really worked against
the OO project as I suddenly had data that couldn't answer simple questions
because they lacked context. This situation is common in OO development, but
not normally noticed, as it is the norm. The DO approach doesn't force any data
to lack context, on the contrary, it enforces flexibility of it by allowing you
to define your schema ad hoc, we haven't seen it properly yet, but once the
game grows the advantages should start to become more apparent.

Interestingly, the OO approach won out (in coding time) in adding bear blocking
code. Adding the bears themselves were about the same complexity as DO, but the
task of making them block was very straight forward in OO dev. The only thing
is, that it was a very short victory as it turns out the reason why it was
simple was that it lacked context, which means adding the owl fight might not
be that simple.
